<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Animation Test</title>
    <link href="style.css" type="text/css" rel="stylesheet"/>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100%;
            height: 100vh;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <script>

/* CANVAS ANIMATION START */

let mouseX = 0;
let prevMouseX = 0;
let mouseY = 0;

document.addEventListener('mousemove', (event) => {
    mouseX = event.clientX;
    mouseY = event.clientY;
});

(function() {
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const CONFIG = {
        lineCount: 10,
        baseXSpread: 600,
        amplitudeMin: 100,
        amplitudeMax: 300,
        frequencyMin: 0.05,
        frequencyMax: 0.1,
        lineWidth: 5,
        opacityMin: 0.05,
        opacityMax: 0.1,
        mouseFlipThreshold: 10
    };

    const computedStyle = getComputedStyle(document.documentElement);
    const colorDark = computedStyle.getPropertyValue('--color-dark').trim();
    const colorLight = computedStyle.getPropertyValue('--color-light').trim();

    class Line {
        constructor(canvas, config) {
            this.canvas = canvas;
            this.config = config;
            this.reset();
        }

        reset() {
            this.baseX = (this.canvas.width / 2) + (Math.random() - 0.5) * 2 * this.config.baseXSpread;
            this.amplitude = Math.random() * (this.config.amplitudeMax - this.config.amplitudeMin) + this.config.amplitudeMin;
            this.frequency = Math.random() * (this.config.frequencyMax - this.config.frequencyMin) + this.config.frequencyMin;
            this.opacity = Math.random() * (this.config.opacityMax - this.config.opacityMin) + this.config.opacityMin;
            this.dir = 1;
        }

        getX(elapsed) {
            return this.baseX + this.dir * this.amplitude * Math.sin(2 * Math.PI * this.frequency * elapsed);
        }

        maybeFlipDirection(x, mouseX) {
            if (Math.abs(x - mouseX) < this.config.mouseFlipThreshold) {
                this.dir *= -1;
            }
        }

        draw(ctx, elapsed) {
            const x = this.getX(elapsed);
            this.maybeFlipDirection(x, mouseX);
            ctx.globalAlpha = this.opacity;
            ctx.fillRect(x - this.config.lineWidth / 2, 0, this.config.lineWidth, this.canvas.height);
        }
    }

    class AnimationManager {
        constructor(canvas, ctx, config) {
            this.canvas = canvas;
            this.ctx = ctx;
            this.config = config;
            this.lines = [];
            this.startTime = Date.now();
        }

        init() {
            this.resize();
            window.addEventListener('resize', () => this.resize());
            this.animate();
        }

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
            this.startTime = Date.now();
            this.lines = Array.from({ length: this.config.lineCount }, () => new Line(this.canvas, this.config));
        }

        getElapsedSeconds(timestamp) {
            return (timestamp - this.startTime) / 1000;
        }

        clear() {
            this.ctx.fillStyle = colorDark;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        detectCollisions(elapsed) {
            const positions = this.lines.map((line, index) => ({
                index,
                x: line.getX(elapsed)
            }));

            const toRemove = new Set();
            for (let i = 0; i < positions.length; i++) {
                for (let j = i + 1; j < positions.length; j++) {
                    if (Math.abs(positions[i].x - positions[j].x) < this.config.lineWidth) {
                        toRemove.add(positions[i].index);
                        toRemove.add(positions[j].index);
                    }
                }
            }

            if (toRemove.size === 0) {
                return;
            }

            this.lines = this.lines.filter((_, index) => !toRemove.has(index));
            for (let i = 0; i < toRemove.size; i++) {
                this.lines.push(new Line(this.canvas, this.config));
            }
        }

        drawLines(elapsed) {
            this.ctx.fillStyle = colorLight;
            for (const line of this.lines) {
                line.draw(this.ctx, elapsed);
            }
        }

        draw(timestamp) {
            prevMouseX = mouseX;
            this.clear();
            const elapsed = this.getElapsedSeconds(timestamp);
            this.detectCollisions(elapsed);
            this.drawLines(elapsed);
        }

        animate() {
            const tick = (timestamp) => {
                this.draw(timestamp);
                requestAnimationFrame(tick);
            };
            requestAnimationFrame(tick);
        }
    }

    const manager = new AnimationManager(canvas, ctx, CONFIG);
    manager.init();
})();
/* CANVAS ANIMATION END */

    
    
</script>
</body>
</html>
